<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SECRET AGENT RUN - 007</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #111;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #eee;
            font-family: 'Press Start 2P', monospace; /* レトロゲームフォント */
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 450px;
            background-color: #000;
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            image-rendering: pixelated; /* ドット絵をくっきり表示 */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ブラウン管（CRT）風のエフェクト - 酔い対策で少し薄く調整 */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.5) 100%);
            pointer-events: none;
            z-index: 11;
        }

        /* UIオーバーレイ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            color: #ffcc00;
            font-size: 40px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        p {
            font-size: 16px;
            color: #fff;
            margin-bottom: 10px;
            line-height: 1.8;
        }

        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }

        #score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 20px;
            color: #fff;
            z-index: 15;
        }

        /* メニュー選択用スタイル */
        .menu-item {
            color: #888;
            margin: 10px 0;
            transition: color 0.1s;
        }
        .menu-item.selected {
            color: #fff;
            background-color: rgba(255, 204, 0, 0.2);
            padding: 5px 15px;
            border-left: 4px solid #ffcc00;
            border-right: 4px solid #ffcc00;
        }
        .menu-instruction {
            font-size: 12px;
            margin-top: 40px;
            color: #aaa;
        }

        .difficulty-label {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 14px;
            color: #ffcc00;
            z-index: 15;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="450"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>

        <div id="score-display">SCORE: 00000</div>
        <div id="difficulty-display" class="difficulty-label hidden">NORMAL</div>

        <div id="ui-layer">
            <div id="start-screen">
                <h1>SECRET AGENT<br>RUN</h1>

                <div id="menu-container">
                    <p id="opt-normal" class="menu-item selected">NORMAL</p>
                    <p id="opt-hard" class="menu-item">HARD</p>
                    <p id="opt-die" class="menu-item">BOND MUST DIE</p>
                </div>

                <p class="menu-instruction">SELECT: [ &uarr; / &darr; ]&nbsp;&nbsp;&nbsp;START: [ ENTER ]</p>
            </div>

            <div id="game-over-screen" class="hidden">
                <h1 style="color: #ff3333;">MISSION FAILED</h1>
                <p id="final-score">SCORE: 0</p>
                <p class="blink">PRESS [ENTER] TO RETRY</p>
            </div>
        </div>
    </div>

<script>
/**
 * ゲームロジック
 */

// キャンバス設定
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiLayer = document.getElementById('ui-layer');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const scoreDisplay = document.getElementById('score-display');
const diffDisplay = document.getElementById('difficulty-display');
const finalScoreText = document.getElementById('final-score');

// メニュー項目
const menuItems = ['opt-normal', 'opt-hard', 'opt-die'];
let currentMenuIndex = 0;
let selectedDifficulty = 'NORMAL';

// ゲーム定数
const GRAVITY = 0.6;
const JUMP_FORCE = -12;
const GROUND_Y = 350;

// 難易度設定
const DIFFICULTY_SETTINGS = {
    'NORMAL': { speed: 4, obsFreq: 0.012, bulletProb: 0.2 },
    'HARD':   { speed: 6, obsFreq: 0.018, bulletProb: 0.5 },
    'DIE':    { speed: 9, obsFreq: 0.025, bulletProb: 0.8 }
};

// 色パレット (NES風)
const COLORS = {
    bg: '#0F380F',
    ground: '#8BAC0F',
    sky: '#000000',
    playerSuit: '#000000',
    playerSkin: '#FFCC99',
    bullet: '#FF3333',
    trap: '#9BBC0F',
    pit: '#000000'
};

// --- サウンド & BGM システム ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const soundEnabled = true;

const playSound = (type) => {
    if (!soundEnabled || audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    if (type === 'jump') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'crash') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    } else if (type === 'shoot') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'select') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(400, audioCtx.currentTime + 0.05);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.05);
    }
};

// BGMコントローラー
class MusicController {
    constructor() {
        this.isPlaying = false;
        this.tempo = 140; // BPM
        this.noteDuration = 60 / this.tempo / 2; // 8分音符
        this.nextNoteTime = 0;
        this.currentNote = 0;
        this.timerID = null;

        // 周波数テーブル
        this.freqs = {
            'E2': 82.41, 'G2': 98.00, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'G3': 196.00, 'A3': 220.00,
            'B3': 246.94, 'C4': 261.63, 'E4': 329.63
        };

        // スパイ風ベースラインパターン
        this.sequence = [
            // Bar 1
            {n:'E2', l:2}, {n:null, l:1}, {n:'E2', l:1}, {n:'G2', l:2}, {n:'E2', l:2},
            // Bar 2
            {n:'A2', l:2}, {n:null, l:1}, {n:'A2', l:1}, {n:'A#2', l:4},
            // Bar 3
            {n:'E2', l:2}, {n:null, l:1}, {n:'E2', l:1}, {n:'G2', l:2}, {n:'E2', l:2},
            // Bar 4
            {n:'A#2', l:2}, {n:null, l:1}, {n:'A#2', l:1}, {n:'A2', l:4},
        ];
    }

    playNote(freq, time, duration) {
        if (!freq) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'triangle'; // ベース音に適した波形
        osc.frequency.value = freq;

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        gain.gain.setValueAtTime(0.15, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration - 0.05);

        osc.start(time);
        osc.stop(time + duration);
    }

    scheduler() {
        while (this.nextNoteTime < audioCtx.currentTime + 0.1) {
            const noteData = this.sequence[this.currentNote % this.sequence.length];
            const length = noteData.l * this.noteDuration;

            if (noteData.n) {
                this.playNote(this.freqs[noteData.n], this.nextNoteTime, length);
            }

            this.nextNoteTime += length;
            this.currentNote++;
        }
    }

    start() {
        if (this.isPlaying) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();

        this.isPlaying = true;
        this.currentNote = 0;
        this.nextNoteTime = audioCtx.currentTime + 0.1;

        this.timerID = setInterval(() => this.scheduler(), 25);
    }

    stop() {
        if (!this.isPlaying) return;
        this.isPlaying = false;
        clearInterval(this.timerID);
    }
}

const bgm = new MusicController();

// --- スプライトデータ ---
const SPRITE_PLAYER_RUN1 = [
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,1,2,2,2,0,0,0],
    [0,0,0,2,2,2,2,0,0,0],
    [0,0,0,1,1,1,1,1,0,0],
    [0,1,1,1,1,2,1,0,0,3],
    [0,0,0,1,1,1,1,3,3,3],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,1,0,0,1,0,0,0],
    [0,0,1,1,0,0,1,1,0,0],
    [0,1,1,0,0,0,0,1,1,0],
    [1,1,0,0,0,0,0,0,0,0]
];

const SPRITE_PLAYER_RUN2 = [
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,1,2,2,2,0,0,0],
    [0,0,0,2,2,2,2,0,0,0],
    [0,0,0,1,1,1,1,1,0,0],
    [0,1,1,1,1,2,1,0,0,3],
    [0,0,0,1,1,1,1,3,3,3],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,0,1,1,0,0,0,0],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,1,1,0,0,1,1,0,0],
    [0,0,1,0,0,0,0,1,0,0]
];

const SPRITE_PLAYER_JUMP = [
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,1,2,2,2,0,0,0],
    [0,0,0,2,2,2,2,0,0,0],
    [0,0,1,1,1,1,1,0,0,0],
    [0,1,1,1,1,2,1,3,3,3],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,0,1,1,1,1,0,0,0],
    [0,0,1,1,0,0,1,0,0,0],
    [0,0,1,0,0,0,1,1,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0]
];

// ゲーム変数
let gameState = 'start';
let frameCount = 0;
let score = 0;
let gameSpeed = 5;
let currentSettings = DIFFICULTY_SETTINGS['NORMAL'];
let obstacles = [];
let particles = [];

// プレイヤーオブジェクト
const player = {
    x: 100,
    y: GROUND_Y,
    width: 40,
    height: 48,
    dy: 0,
    jumpCount: 0,
    maxJumps: 2,
    grounded: true,
    spriteScale: 4,

    draw: function() {
        let sprite = SPRITE_PLAYER_RUN1;
        if (!this.grounded) {
            sprite = SPRITE_PLAYER_JUMP;
        } else {
            const animSpeed = Math.max(5, 15 - Math.floor(gameSpeed));
            if (Math.floor(frameCount / animSpeed) % 2 === 0) {
                sprite = SPRITE_PLAYER_RUN1;
            } else {
                sprite = SPRITE_PLAYER_RUN2;
            }
        }

        drawSprite(sprite, this.x, this.y - this.height, this.spriteScale, false);
    },

    update: function() {
        this.dy += GRAVITY;
        this.y += this.dy;

        if (this.y > GROUND_Y) {
            this.y = GROUND_Y;
            this.dy = 0;
            this.grounded = true;
            this.jumpCount = 0;
        } else {
            this.grounded = false;
        }
    },

    jump: function() {
        if (this.jumpCount < this.maxJumps) {
            this.dy = JUMP_FORCE;
            this.jumpCount++;
            this.grounded = false;
            playSound('jump');
            createParticles(this.x + 20, this.y, 5, '#FFF');
        }
    }
};

// 障害物クラス
class Obstacle {
    constructor() {
        this.x = canvas.width;

        const rand = Math.random();
        const bulletThreshold = 1.0 - currentSettings.bulletProb;

        if (rand > bulletThreshold) {
            this.type = 'bullet';
            this.width = 24;
            this.height = 12;
            this.y = GROUND_Y - 35;
            playSound('shoot');
        } else {
            if (Math.random() > 0.5) {
                this.type = 'pit';
                this.width = 70;
                this.height = 60;
                this.y = GROUND_Y;
            } else {
                this.type = 'trap';
                this.width = 30;
                this.height = 30;
                this.y = GROUND_Y;
            }
        }

        this.markedForDeletion = false;
    }

    update() {
        let speedMultiplier = 1;
        if (this.type === 'bullet') {
            if (selectedDifficulty === 'DIE') speedMultiplier = 2.0;
            else speedMultiplier = 1.5;
        }

        this.x -= gameSpeed * speedMultiplier;

        if (this.x + this.width < 0) {
            this.markedForDeletion = true;
            score += 100;
        }
    }

    draw() {
        if (this.type === 'pit') {
            ctx.fillStyle = COLORS.pit;
            ctx.fillRect(this.x, GROUND_Y - 2, this.width, 100);
        } else if (this.type === 'trap') {
            ctx.fillStyle = COLORS.trap;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.width / 2, this.y - this.height);
            ctx.lineTo(this.x + this.width, this.y);
            ctx.fill();
            if (Math.floor(frameCount / 10) % 2 === 0) {
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x + this.width/2 - 2, this.y - this.height + 2, 4, 4);
            }
        } else if (this.type === 'bullet') {
            ctx.fillStyle = COLORS.bullet;
            ctx.fillRect(this.x, this.y - this.height, this.width, this.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(this.x + this.width, this.y - this.height + 4, 20, 4);
        }
    }
}

// パーティクル
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 5 + 2;
        this.speedX = Math.random() * 3 - 1.5;
        this.speedY = Math.random() * 3 - 1.5;
        this.color = color;
        this.life = 1.0;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= 0.05;
    }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

function createParticles(x, y, count, color) {
    for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

// ユーティリティ
function drawSprite(spriteMap, startX, startY, scale, flipX) {
    for (let row = 0; row < spriteMap.length; row++) {
        for (let col = 0; col < spriteMap[row].length; col++) {
            const pixel = spriteMap[row][col];
            if (pixel !== 0) {
                let drawX = startX + col * scale;
                if (flipX) drawX = startX + (spriteMap[row].length - 1 - col) * scale;
                const drawY = startY + row * scale;

                if (pixel === 1) ctx.fillStyle = COLORS.playerSuit;
                else if (pixel === 2) ctx.fillStyle = COLORS.playerSkin;
                else if (pixel === 3) ctx.fillStyle = '#666';

                ctx.fillRect(drawX, drawY, scale, scale);
            }
        }
    }
}

// 背景描画
function drawBackground() {
    ctx.fillStyle = COLORS.sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 月
    ctx.fillStyle = '#DDD';
    ctx.beginPath();
    ctx.arc(700, 80, 40, 0, Math.PI * 2);
    ctx.fill();

    // 遠いビル
    ctx.fillStyle = '#1a1a2e';
    const bgOffset = (frameCount * 0.2) % 100;
    for(let i = 0; i < 10; i++) {
        const h = 100 + Math.sin(i * 132) * 50;
        ctx.fillRect(i * 100 - bgOffset, GROUND_Y - h, 100, h);
    }

    // 近いビル
    ctx.fillStyle = '#0F2A3F';
    const midOffset = (frameCount * 0.8) % 150;
    for(let i = 0; i < 8; i++) {
        const h = 150 + Math.cos(i * 45) * 60;
        ctx.fillRect(i * 150 - midOffset, GROUND_Y - h, 140, h);

        ctx.fillStyle = (frameCount % 60 < 30) ? '#333' : '#442';
        for(let w=0; w<5; w++) {
            for(let wh=0; wh<5; wh++) {
                if((i+w+wh)%3 === 0)
                ctx.fillRect(i * 150 - midOffset + 20 + w*20, GROUND_Y - h + 20 + wh*30, 10, 20);
            }
        }
        ctx.fillStyle = '#0F2A3F';
    }

    // 地面
    ctx.fillStyle = COLORS.ground;
    ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

    // 地面のグリッド
    ctx.fillStyle = '#5A7C00';
    const groundOffset = (frameCount * gameSpeed) % 40;
    for (let i = 0; i < canvas.width + 40; i+= 40) {
        ctx.fillRect(i - groundOffset, GROUND_Y, 2, canvas.height - GROUND_Y);
    }
}

// 衝突判定
function checkCollision(player, obstacle) {
    const hitBox = {
        x: player.x + 10,
        y: player.y - player.height + 5,
        w: player.width - 15,
        h: player.height - 10
    };

    if (obstacle.type === 'pit') {
        const playerCenter = player.x + player.width / 2;
        if (playerCenter > obstacle.x && playerCenter < obstacle.x + obstacle.width) {
            if (player.y >= GROUND_Y - 5) return true;
        }
    } else {
        const obsBox = {
            x: obstacle.x + 5,
            y: obstacle.y - obstacle.height + 5,
            w: obstacle.width - 10,
            h: obstacle.height - 10
        };

        if (
            hitBox.x < obsBox.x + obsBox.w &&
            hitBox.x + hitBox.w > obsBox.x &&
            hitBox.y < obsBox.y + obsBox.h &&
            hitBox.y + hitBox.h > obsBox.y
        ) {
            return true;
        }
    }
    return false;
}

// ゲームループ
function update() {
    if (gameState !== 'playing') return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();

    score++;
    scoreDisplay.innerText = `SCORE: ${String(score).padStart(5, '0')}`;

    if (score % 500 === 0) {
        gameSpeed += 0.5;
    }

    player.update();
    player.draw();

    if (Math.random() < currentSettings.obsFreq + (score * 0.000005)) {
        if (obstacles.length === 0 || canvas.width - obstacles[obstacles.length - 1].x > 300) {
            obstacles.push(new Obstacle());
        }
    }

    obstacles.forEach(obs => {
        obs.update();
        obs.draw();
        if (checkCollision(player, obs)) gameOver();
    });

    obstacles = obstacles.filter(obs => !obs.markedForDeletion);

    particles.forEach((p, index) => {
        p.update();
        p.draw();
        if (p.life <= 0) particles.splice(index, 1);
    });

    frameCount++;
    requestAnimationFrame(update);
}

function resetGame() {
    score = 0;
    frameCount = 0;
    currentSettings = DIFFICULTY_SETTINGS[selectedDifficulty];
    gameSpeed = currentSettings.speed;

    obstacles = [];
    particles = [];
    player.y = GROUND_Y;
    player.dy = 0;
    player.jumpCount = 0;
    scoreDisplay.innerText = `SCORE: 00000`;
    diffDisplay.innerText = selectedDifficulty;
    diffDisplay.classList.remove('hidden');
}

function startGame() {
    gameState = 'playing';
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    resetGame();
    audioCtx.resume();
    bgm.start(); // BGM開始
    update();
}

function gameOver() {
    gameState = 'gameover';
    bgm.stop(); // BGM停止
    playSound('crash');
    createParticles(player.x + 20, player.y - 20, 30, '#ff3300');
    finalScoreText.innerText = `SCORE: ${score}`;
    gameOverScreen.classList.remove('hidden');
}

function updateMenuUI() {
    menuItems.forEach((id, index) => {
        const el = document.getElementById(id);
        if (index === currentMenuIndex) {
            el.classList.add('selected');
        } else {
            el.classList.remove('selected');
        }
    });
}

// キー入力ハンドリング
window.addEventListener('keydown', (e) => {
    // スクロール防止
    if (['ArrowUp', 'ArrowDown', 'Enter', ' '].includes(e.key)) {
        e.preventDefault();
    }

    if (gameState === 'start') {
        if (e.key === 'ArrowUp') {
            playSound('select');
            currentMenuIndex = (currentMenuIndex - 1 + menuItems.length) % menuItems.length;
            updateDifficultySelection();
            updateMenuUI();
        } else if (e.key === 'ArrowDown') {
            playSound('select');
            currentMenuIndex = (currentMenuIndex + 1) % menuItems.length;
            updateDifficultySelection();
            updateMenuUI();
        } else if (e.key === 'Enter') {
            startGame();
        }
    } else if (gameState === 'playing') {
        if (e.key === 'Enter') {
            player.jump();
        }
    } else if (gameState === 'gameover') {
        if (e.key === 'Enter') {
            setTimeout(() => {
                gameState = 'start';
                startScreen.classList.remove('hidden');
                gameOverScreen.classList.add('hidden');
                currentMenuIndex = 0;
                selectedDifficulty = 'NORMAL';
                updateDifficultySelection();
                updateMenuUI();
                initialDraw();
            }, 200);
        }
    }
});

function updateDifficultySelection() {
    if (currentMenuIndex === 0) selectedDifficulty = 'NORMAL';
    if (currentMenuIndex === 1) selectedDifficulty = 'HARD';
    if (currentMenuIndex === 2) selectedDifficulty = 'DIE';
}

function initialDraw() {
    drawBackground();
    player.draw();
}
initialDraw();

</script>
</body>
</html>
